/**
 * Docker Engine API The Engine API is an HTTP API served by Docker Engine. It is the API the Docker
 * client uses to communicate with the Engine, so everything the Docker client can do can be done
 * with the API. Most of the client's commands map directly to API endpoints (e.g. `docker ps` is
 * `GET /containers/json`). The notable exception is running containers, which consists of several
 * API calls. # Errors The API uses standard HTTP status codes to indicate the success or failure of
 * the API call. The body of the response will be JSON in the following format: ``` { \"message\":
 * \"page not found\" } ``` # Versioning The API is usually changed in each release, so API calls
 * are versioned to ensure that clients don't break. To lock to a specific version of the API, you
 * prefix the URL with its version, for example, call `/v1.30/info` to use the v1.30 version of the
 * `/info` endpoint. If the API version specified in the URL is not supported by the daemon, a HTTP
 * `400 Bad Request` error message is returned. If you omit the version-prefix, the current version
 * of the API (v1.43) is used. For example, calling `/info` is the same as calling `/v1.43/info`.
 * Using the API without a version-prefix is deprecated and will be removed in a future release.
 * Engine releases in the near future should support this version of the API, so your client will
 * continue to work even if it is talking to a newer Engine. The API uses an open schema model,
 * which means server may add extra properties to responses. Likewise, the server will ignore any
 * extra query parameters and request body properties. When you write clients, you need to ignore
 * additional properties in responses to ensure they do not break when talking to newer daemons. #
 * Authentication Authentication for registries is handled client side. The client has to send
 * authentication details to various endpoints that need to communicate with registries, such as
 * `POST /images/(name)/push`. These are sent as `X-Registry-Auth` header as a [base64url
 * encoded](https://tools.ietf.org/html/rfc4648#section-5) (JSON) string with the following
 * structure: ``` { \"username\": \"string\", \"password\": \"string\", \"email\": \"string\",
 * \"serveraddress\": \"string\" } ``` The `serveraddress` is a domain/IP without a protocol.
 * Throughout this structure, double quotes are required. If you have already got an identity token
 * from the [`/auth` endpoint](#operation/SystemAuth), you can just pass this instead of
 * credentials: ``` { \"identitytoken\": \"9cbaf023786cd7...\" } ```
 *
 * The version of the OpenAPI document: 1.43
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech Do not edit the class manually.
 */
package org.openapitools.client.api

import org.openapitools.client.model.ErrorResponse
import java.io.File
import org.openapitools.client.model.Service
import org.openapitools.client.model.ServiceCreateRequest
import org.openapitools.client.model.ServiceCreateResponse
import org.openapitools.client.model.ServiceUpdateRequest
import org.openapitools.client.model.ServiceUpdateResponse
import org.openapitools.client.core.JsonSupport.{*, given}
import sttp.client4.*
import sttp.model.Method

object ServiceApi:
  def apply(baseUrl: String = "http://localhost/v1.43") = new ServiceApi(baseUrl)

end ServiceApi

class ServiceApi(baseUrl: String):

  /**
   * Expected answers: code 201 : ServiceCreateResponse (no error) code 400 : ErrorResponse (bad
   * parameter) code 403 : ErrorResponse (network is not eligible for services) code 409 :
   * ErrorResponse (name conflicts with an existing service) code 500 : ErrorResponse (server error)
   * code 503 : ErrorResponse (node is not part of a swarm)
   *
   * @param body
   * @param xRegistryAuth
   *   A base64url-encoded auth configuration for pulling from private registries. Refer to the
   *   [authentication section](#section/Authentication) for details.
   */
  def serviceCreate(body: ServiceCreateRequest, xRegistryAuth: Option[String] = None)
      : Request[Either[ResponseException[String, Exception], ServiceCreateResponse]] =
    basicRequest
      .method(Method.POST, uri"$baseUrl/services/create")
      .contentType("application/json")
      .header("X-Registry-Auth", xRegistryAuth.toString)
      .body(body)
      .response(asJson[ServiceCreateResponse])

  /**
   * Expected answers: code 200 : (no error) code 404 : ErrorResponse (no such service) code 500 :
   * ErrorResponse (server error) code 503 : ErrorResponse (node is not part of a swarm)
   *
   * @param id
   *   ID or name of service.
   */
  def serviceDelete(id: String): Request[Either[ResponseException[String, Exception], Unit]] =
    basicRequest
      .method(Method.DELETE, uri"$baseUrl/services/${id}")
      .contentType("application/json")
      .response(asString.mapWithMetadata(ResponseAs.deserializeRightWithError(_ => Right(()))))

  /**
   * Expected answers: code 200 : Service (no error) code 404 : ErrorResponse (no such service) code
   * 500 : ErrorResponse (server error) code 503 : ErrorResponse (node is not part of a swarm)
   *
   * @param id
   *   ID or name of service.
   * @param insertDefaults
   *   Fill empty fields with default values.
   */
  def serviceInspect(id: String, insertDefaults: Option[Boolean] = None)
      : Request[Either[ResponseException[String, Exception], Service]] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/services/${id}?insertDefaults=${insertDefaults}")
      .contentType("application/json")
      .response(asJson[Service])

  /**
   * Expected answers: code 200 : Seq[Service] (no error) code 500 : ErrorResponse (server error)
   * code 503 : ErrorResponse (node is not part of a swarm)
   *
   * @param filters
   *   A JSON encoded value of the filters (a `map[string][]string`) to process on the services
   *   list. Available filters: - `id=<service id>` - `label=<service label>` -
   *   `mode=[\"replicated\"|\"global\"]` - `name=<service name>`
   * @param status
   *   Include service status, with count of running and desired tasks.
   */
  def serviceList(filters: Option[String] = None, status: Option[Boolean] = None)
      : Request[Either[ResponseException[String, Exception], Seq[Service]]] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/services?filters=${filters}&status=${status}")
      .contentType("application/json")
      .response(asJson[Seq[Service]])

  /**
   * Get `stdout` and `stderr` logs from a service. See also
   * [`/containers/{id}/logs`](#operation/ContainerLogs). **Note**: This endpoint works only for
   * services with the `local`, `json-file` or `journald` logging drivers.
   *
   * Expected answers: code 200 : File (logs returned as a stream in response body) code 404 :
   * ErrorResponse (no such service) code 500 : ErrorResponse (server error) code 503 :
   * ErrorResponse (node is not part of a swarm)
   *
   * @param id
   *   ID or name of the service
   * @param details
   *   Show service context and extra details provided to logs.
   * @param follow
   *   Keep connection after returning logs.
   * @param stdout
   *   Return logs from `stdout`
   * @param stderr
   *   Return logs from `stderr`
   * @param since
   *   Only return logs since this time, as a UNIX timestamp
   * @param timestamps
   *   Add timestamps to every log line
   * @param tail
   *   Only return this number of log lines from the end of the logs. Specify as an integer or `all`
   *   to output all log lines.
   */
  def serviceLogs(
      id: String,
      details: Option[Boolean] = None,
      follow: Option[Boolean] = None,
      stdout: Option[Boolean] = None,
      stderr: Option[Boolean] = None,
      since: Option[Int] = None,
      timestamps: Option[Boolean] = None,
      tail: Option[String] = None,
    ): Request[Either[ResponseException[String, Exception], String]] =
    basicRequest
      .method(
        Method.GET,
        uri"$baseUrl/services/${id}/logs?details=${details}&follow=${follow}&stdout=${stdout}&stderr=${stderr}&since=${since}&timestamps=${timestamps}&tail=${tail}",
      )
      .contentType("application/json")
      .response(asJson[String])

  /**
   * Expected answers: code 200 : ServiceUpdateResponse (no error) code 400 : ErrorResponse (bad
   * parameter) code 404 : ErrorResponse (no such service) code 500 : ErrorResponse (server error)
   * code 503 : ErrorResponse (node is not part of a swarm)
   *
   * @param id
   *   ID or name of service.
   * @param version
   *   The version number of the service object being updated. This is required to avoid conflicting
   *   writes. This version number should be the value as currently set on the service *before* the
   *   update. You can find the current version by calling `GET /services/{id}`
   * @param body
   * @param registryAuthFrom
   *   If the `X-Registry-Auth` header is not specified, this parameter indicates where to find
   *   registry authorization credentials.
   * @param rollback
   *   Set to this parameter to `previous` to cause a server-side rollback to the previous service
   *   spec. The supplied spec will be ignored in this case.
   * @param xRegistryAuth
   *   A base64url-encoded auth configuration for pulling from private registries. Refer to the
   *   [authentication section](#section/Authentication) for details.
   */
  def serviceUpdate(
      id: String,
      version: Int,
      body: ServiceUpdateRequest,
      registryAuthFrom: Option[String] = None,
      rollback: Option[String] = None,
      xRegistryAuth: Option[String] = None,
    ): Request[Either[ResponseException[String, Exception], ServiceUpdateResponse]] =
    basicRequest
      .method(
        Method.POST,
        uri"$baseUrl/services/${id}/update?version=${version}&registryAuthFrom=${registryAuthFrom}&rollback=${rollback}",
      )
      .contentType("application/json")
      .header("X-Registry-Auth", xRegistryAuth.toString)
      .body(body)
      .response(asJson[ServiceUpdateResponse])

end ServiceApi
