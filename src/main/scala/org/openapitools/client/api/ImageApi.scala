/**
 * Docker Engine API The Engine API is an HTTP API served by Docker Engine. It is the API the Docker
 * client uses to communicate with the Engine, so everything the Docker client can do can be done
 * with the API. Most of the client's commands map directly to API endpoints (e.g. `docker ps` is
 * `GET /containers/json`). The notable exception is running containers, which consists of several
 * API calls. # Errors The API uses standard HTTP status codes to indicate the success or failure of
 * the API call. The body of the response will be JSON in the following format: ``` { \"message\":
 * \"page not found\" } ``` # Versioning The API is usually changed in each release, so API calls
 * are versioned to ensure that clients don't break. To lock to a specific version of the API, you
 * prefix the URL with its version, for example, call `/v1.30/info` to use the v1.30 version of the
 * `/info` endpoint. If the API version specified in the URL is not supported by the daemon, a HTTP
 * `400 Bad Request` error message is returned. If you omit the version-prefix, the current version
 * of the API (v1.43) is used. For example, calling `/info` is the same as calling `/v1.43/info`.
 * Using the API without a version-prefix is deprecated and will be removed in a future release.
 * Engine releases in the near future should support this version of the API, so your client will
 * continue to work even if it is talking to a newer Engine. The API uses an open schema model,
 * which means server may add extra properties to responses. Likewise, the server will ignore any
 * extra query parameters and request body properties. When you write clients, you need to ignore
 * additional properties in responses to ensure they do not break when talking to newer daemons. #
 * Authentication Authentication for registries is handled client side. The client has to send
 * authentication details to various endpoints that need to communicate with registries, such as
 * `POST /images/(name)/push`. These are sent as `X-Registry-Auth` header as a [base64url
 * encoded](https://tools.ietf.org/html/rfc4648#section-5) (JSON) string with the following
 * structure: ``` { \"username\": \"string\", \"password\": \"string\", \"email\": \"string\",
 * \"serveraddress\": \"string\" } ``` The `serveraddress` is a domain/IP without a protocol.
 * Throughout this structure, double quotes are required. If you have already got an identity token
 * from the [`/auth` endpoint](#operation/SystemAuth), you can just pass this instead of
 * credentials: ``` { \"identitytoken\": \"9cbaf023786cd7...\" } ```
 *
 * The version of the OpenAPI document: 1.43
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech Do not edit the class manually.
 */
package org.openapitools.client.api

import org.openapitools.client.model.BuildPruneResponse
import org.openapitools.client.model.ContainerConfig
import org.openapitools.client.model.ErrorResponse
import org.openapitools.client.model.HistoryResponseItem
import org.openapitools.client.model.IdResponse
import org.openapitools.client.model.ImageDeleteResponseItem
import org.openapitools.client.model.ImageInspect
import org.openapitools.client.model.ImagePruneResponse
import org.openapitools.client.model.ImageSearchResponseItem
import org.openapitools.client.model.ImageSummary
import org.openapitools.client.core.JsonSupport.{*, given}
import sttp.client4.*
import sttp.model.Method

object ImageApi:
  def apply(baseUrl: String = "http://localhost/v1.43") = new ImageApi(baseUrl)

end ImageApi

class ImageApi(baseUrl: String):

  /**
   * Expected answers: code 200 : BuildPruneResponse (No error) code 500 : ErrorResponse (Server
   * error)
   *
   * @param keepStorage
   *   Amount of disk space in bytes to keep for cache
   * @param all
   *   Remove all types of build cache
   * @param filters
   *   A JSON encoded value of the filters (a `map[string][]string`) to process on the list of build
   *   cache objects. Available filters: - `until=<timestamp>` remove cache older than
   *   `<timestamp>`. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go
   *   duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon's local time. -
   *   `id=<id>` - `parent=<id>` - `type=<string>` - `description=<string>` - `inuse` - `shared` -
   *   `private`
   */
  def buildPrune(
      keepStorage: Option[Long] = None,
      all: Option[Boolean] = None,
      filters: Option[String] = None,
    ): Request[Either[ResponseException[String, Exception], BuildPruneResponse]] =
    basicRequest
      .method(
        Method.POST,
        uri"$baseUrl/build/prune?keep-storage=${keepStorage}&all=${all}&filters=${filters}",
      )
      .contentType("application/json")
      .response(asJson[BuildPruneResponse])

  /**
   * Build an image from a tar archive with a `Dockerfile` in it. The `Dockerfile` specifies how the
   * image is built from the tar archive. It is typically in the archive's root, but can be at a
   * different path or have a different name by specifying the `dockerfile` parameter. [See the
   * `Dockerfile` reference for more
   * information](https://docs.docker.com/engine/reference/builder/). The Docker daemon performs a
   * preliminary validation of the `Dockerfile` before starting the build, and returns an error if
   * the syntax is incorrect. After that, each instruction is run one-by-one until the ID of the new
   * image is output. The build is canceled if the client drops the connection by quitting or being
   * killed.
   *
   * Expected answers: code 200 : (no error) code 400 : ErrorResponse (Bad parameter) code 500 :
   * ErrorResponse (server error)
   *
   * @param dockerfile
   *   Path within the build context to the `Dockerfile`. This is ignored if `remote` is specified
   *   and points to an external `Dockerfile`.
   * @param `t`
   *   A name and optional tag to apply to the image in the `name:tag` format. If you omit the tag
   *   the default `latest` value is assumed. You can provide several `t` parameters.
   * @param extrahosts
   *   Extra hosts to add to /etc/hosts
   * @param remote
   *   A Git repository URI or HTTP/HTTPS context URI. If the URI points to a single text file, the
   *   fileâ€™s contents are placed into a file called `Dockerfile` and the image is built from that
   *   file. If the URI points to a tarball, the file is downloaded by the daemon and the contents
   *   therein used as the context for the build. If the URI points to a tarball and the
   *   `dockerfile` parameter is also specified, there must be a file with the corresponding path
   *   inside the tarball.
   * @param `q`
   *   Suppress verbose build output.
   * @param nocache
   *   Do not use the cache when building the image.
   * @param cachefrom
   *   JSON array of images used for build cache resolution.
   * @param pull
   *   Attempt to pull the image even if an older image exists locally.
   * @param rm
   *   Remove intermediate containers after a successful build.
   * @param forcerm
   *   Always remove intermediate containers, even upon failure.
   * @param memory
   *   Set memory limit for build.
   * @param memswap
   *   Total memory (memory + swap). Set as `-1` to disable swap.
   * @param cpushares
   *   CPU shares (relative weight).
   * @param cpusetcpus
   *   CPUs in which to allow execution (e.g., `0-3`, `0,1`).
   * @param cpuperiod
   *   The length of a CPU period in microseconds.
   * @param cpuquota
   *   Microseconds of CPU time that the container can get in a CPU period.
   * @param buildargs
   *   JSON map of string pairs for build-time variables. Users pass these values at build-time.
   *   Docker uses the buildargs as the environment context for commands run via the `Dockerfile`
   *   RUN instruction, or for variable expansion in other `Dockerfile` instructions. This is not
   *   meant for passing secret values. For example, the build arg `FOO=bar` would become
   *   `{\"FOO\":\"bar\"}` in JSON. This would result in the query parameter
   *   `buildargs={\"FOO\":\"bar\"}`. Note that `{\"FOO\":\"bar\"}` should be URI component encoded.
   *   [Read more about the buildargs
   *   instruction.](https://docs.docker.com/engine/reference/builder/#arg)
   * @param shmsize
   *   Size of `/dev/shm` in bytes. The size must be greater than 0. If omitted the system uses
   *   64MB.
   * @param squash
   *   Squash the resulting images layers into a single layer. *(Experimental release only.)*
   * @param labels
   *   Arbitrary key/value labels to set on the image, as a JSON map of string pairs.
   * @param networkmode
   *   Sets the networking mode for the run commands during build. Supported standard values are:
   *   `bridge`, `host`, `none`, and `container:<name|id>`. Any other value is taken as a custom
   *   network's name or ID to which this container should connect to.
   * @param contentType
   * @param xRegistryConfig
   *   This is a base64-encoded JSON object with auth configurations for multiple registries that a
   *   build may refer to. The key is a registry URL, and the value is an auth configuration object,
   *   [as described in the authentication section](#section/Authentication). For example: ``` {
   *   \"docker.example.com\": { \"username\": \"janedoe\", \"password\": \"hunter2\" },
   *   \"https://index.docker.io/v1/\": { \"username\": \"mobydock\", \"password\":
   *   \"conta1n3rize14\" } } ``` Only the registry domain name (and port if not the default 443)
   *   are required. However, for legacy reasons, the Docker Hub registry must be specified with
   *   both a `https://` prefix and a `/v1/` suffix even though Docker will prefer to use the v2
   *   registry API.
   * @param platform
   *   Platform in the format os[/arch[/variant]]
   * @param target
   *   Target build stage
   * @param outputs
   *   BuildKit output configuration
   * @param version
   *   Version of the builder backend to use. - `1` is the first generation classic (deprecated)
   *   builder in the Docker daemon (default) - `2` is [BuildKit](https://github.com/moby/buildkit)
   * @param inputStream
   *   A tar archive compressed with one of the following algorithms: identity (no compression),
   *   gzip, bzip2, xz.
   */
  def imageBuild(
      dockerfile: Option[String] = None,
      `t`: Option[String] = None,
      extrahosts: Option[String] = None,
      remote: Option[String] = None,
      `q`: Option[Boolean] = None,
      nocache: Option[Boolean] = None,
      cachefrom: Option[String] = None,
      pull: Option[String] = None,
      rm: Option[Boolean] = None,
      forcerm: Option[Boolean] = None,
      memory: Option[Int] = None,
      memswap: Option[Int] = None,
      cpushares: Option[Int] = None,
      cpusetcpus: Option[String] = None,
      cpuperiod: Option[Int] = None,
      cpuquota: Option[Int] = None,
      buildargs: Option[String] = None,
      shmsize: Option[Int] = None,
      squash: Option[Boolean] = None,
      labels: Option[String] = None,
      networkmode: Option[String] = None,
      contentType: Option[String] = None,
      xRegistryConfig: Option[String] = None,
      platform: Option[String] = None,
      target: Option[String] = None,
      outputs: Option[String] = None,
      version: Option[String] = None,
      inputStream: Option[String] = None,
    ): Request[Either[ResponseException[String, Exception], Unit]] =
    basicRequest
      .method(
        Method.POST,
        uri"$baseUrl/build?dockerfile=${dockerfile}&t=${`t`}&extrahosts=${extrahosts}&remote=${remote}&q=${`q`}&nocache=${nocache}&cachefrom=${cachefrom}&pull=${pull}&rm=${rm}&forcerm=${forcerm}&memory=${memory}&memswap=${memswap}&cpushares=${cpushares}&cpusetcpus=${cpusetcpus}&cpuperiod=${cpuperiod}&cpuquota=${cpuquota}&buildargs=${buildargs}&shmsize=${shmsize}&squash=${squash}&labels=${labels}&networkmode=${networkmode}&platform=${platform}&target=${target}&outputs=${outputs}&version=${version}",
      )
      .contentType("application/octet-stream")
      .header("Content-type", contentType.toString)
      .header("X-Registry-Config", xRegistryConfig.toString)
      .body(inputStream)
      .response(asString.mapWithMetadata(ResponseAs.deserializeRightWithError(_ => Right(()))))

  /**
   * Expected answers: code 201 : IdResponse (no error) code 404 : ErrorResponse (no such container)
   * code 500 : ErrorResponse (server error)
   *
   * @param container
   *   The ID or name of the container to commit
   * @param repo
   *   Repository name for the created image
   * @param tag
   *   Tag name for the create image
   * @param comment
   *   Commit message
   * @param author
   *   Author of the image (e.g., `John Hannibal Smith <hannibal@a-team.com>`)
   * @param pause
   *   Whether to pause the container before committing
   * @param changes
   *   `Dockerfile` instructions to apply while committing
   * @param containerConfig
   *   The container configuration
   */
  def imageCommit(
      container: Option[String] = None,
      repo: Option[String] = None,
      tag: Option[String] = None,
      comment: Option[String] = None,
      author: Option[String] = None,
      pause: Option[Boolean] = None,
      changes: Option[String] = None,
      containerConfig: Option[ContainerConfig] = None,
    ): Request[Either[ResponseException[String, Exception], IdResponse]] =
    basicRequest
      .method(
        Method.POST,
        uri"$baseUrl/commit?container=${container}&repo=${repo}&tag=${tag}&comment=${comment}&author=${author}&pause=${pause}&changes=${changes}",
      )
      .contentType("application/json")
      .body(containerConfig)
      .response(asJson[IdResponse])

  /**
   * Create an image by either pulling it from a registry or importing it.
   *
   * Expected answers: code 200 : (no error) code 404 : ErrorResponse (repository does not exist or
   * no read access) code 500 : ErrorResponse (server error)
   *
   * @param fromImage
   *   Name of the image to pull. The name may include a tag or digest. This parameter may only be
   *   used when pulling an image. The pull is cancelled if the HTTP connection is closed.
   * @param fromSrc
   *   Source to import. The value may be a URL from which the image can be retrieved or `-` to read
   *   the image from the request body. This parameter may only be used when importing an image.
   * @param repo
   *   Repository name given to an image when it is imported. The repo may include a tag. This
   *   parameter may only be used when importing an image.
   * @param tag
   *   Tag or digest. If empty when pulling an image, this causes all tags for the given image to be
   *   pulled.
   * @param message
   *   Set commit message for imported image.
   * @param xRegistryAuth
   *   A base64url-encoded auth configuration. Refer to the [authentication
   *   section](#section/Authentication) for details.
   * @param changes
   *   Apply `Dockerfile` instructions to the image that is created, for example: `changes=ENV
   *   DEBUG=true`. Note that `ENV DEBUG=true` should be URI component encoded. Supported
   *   `Dockerfile` instructions:
   *   `CMD`|`ENTRYPOINT`|`ENV`|`EXPOSE`|`ONBUILD`|`USER`|`VOLUME`|`WORKDIR`
   * @param platform
   *   Platform in the format os[/arch[/variant]]. When used in combination with the `fromImage`
   *   option, the daemon checks if the given image is present in the local image cache with the
   *   given OS and Architecture, and otherwise attempts to pull the image. If the option is not
   *   set, the host's native OS and Architecture are used. If the given image does not exist in the
   *   local image cache, the daemon attempts to pull the image with the host's native OS and
   *   Architecture. If the given image does exists in the local image cache, but its OS or
   *   architecture does not match, a warning is produced. When used with the `fromSrc` option to
   *   import an image from an archive, this option sets the platform information for the imported
   *   image. If the option is not set, the host's native OS and Architecture are used for the
   *   imported image.
   * @param inputImage
   *   Image content if the value `-` has been specified in fromSrc query parameter
   */
  def imageCreate(
      fromImage: Option[String] = None,
      fromSrc: Option[String] = None,
      repo: Option[String] = None,
      tag: Option[String] = None,
      message: Option[String] = None,
      xRegistryAuth: Option[String] = None,
      changes: Seq[String],
      platform: Option[String] = None,
      inputImage: Option[String] = None,
    ): Request[Either[ResponseException[String, Exception], Unit]] =
    basicRequest
      .method(
        Method.POST,
        uri"$baseUrl/images/create?fromImage=${fromImage}&fromSrc=${fromSrc}&repo=${repo}&tag=${tag}&message=${message}&changes=${changes}&platform=${platform}",
      )
      .contentType("text/plain")
      .header("X-Registry-Auth", xRegistryAuth.toString)
      .body(inputImage)
      .response(asString.mapWithMetadata(ResponseAs.deserializeRightWithError(_ => Right(()))))

  /**
   * Remove an image, along with any untagged parent images that were referenced by that image.
   * Images can't be removed if they have descendant images, are being used by a running container
   * or are being used by a build.
   *
   * Expected answers: code 200 : Seq[ImageDeleteResponseItem] (The image was deleted successfully)
   * code 404 : ErrorResponse (No such image) code 409 : ErrorResponse (Conflict) code 500 :
   * ErrorResponse (Server error)
   *
   * @param name
   *   Image name or ID
   * @param force
   *   Remove the image even if it is being used by stopped containers or has other tags
   * @param noprune
   *   Do not delete untagged parent images
   */
  def imageDelete(
      name: String,
      force: Option[Boolean] = None,
      noprune: Option[Boolean] = None,
    ): Request[Either[ResponseException[String, Exception], Seq[ImageDeleteResponseItem]]] =
    basicRequest
      .method(Method.DELETE, uri"$baseUrl/images/${name}?force=${force}&noprune=${noprune}")
      .contentType("application/json")
      .response(asJson[Seq[ImageDeleteResponseItem]])

  /**
   * Get a tarball containing all images and metadata for a repository. If `name` is a specific name
   * and tag (e.g. `ubuntu:latest`), then only that image (and its parents) are returned. If `name`
   * is an image ID, similarly only that image (and its parents) are returned, but with the
   * exclusion of the `repositories` file in the tarball, as there were no image names referenced.
   * ### Image tarball format An image tarball contains one directory per image layer (named using
   * its long ID), each containing these files: - `VERSION`: currently `1.0` - the file format
   * version - `json`: detailed layer information, similar to `docker inspect layer_id` -
   * `layer.tar`: A tarfile containing the filesystem changes in this layer The `layer.tar` file
   * contains `aufs` style `.wh..wh.aufs` files and directories for storing attribute changes and
   * deletions. If the tarball defines a repository, the tarball should also include a
   * `repositories` file at the root that contains a list of repository and tag names mapped to
   * layer IDs. ```json { \"hello-world\": { \"latest\":
   * \"565a9d68a73f6706862bfe8409a7f659776d4d60a8d096eb4a3cbce6999cc2a1\" } } ```
   *
   * Expected answers: code 200 : File (no error) code 500 : ErrorResponse (server error)
   *
   * @param name
   *   Image name or ID
   */
  def imageGet(name: String): Request[Either[ResponseException[String, Exception], String]] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/images/${name}/get")
      .contentType("application/json")
      .response(asJson[String])

  /**
   * Get a tarball containing all images and metadata for several image repositories. For each value
   * of the `names` parameter: if it is a specific name and tag (e.g. `ubuntu:latest`), then only
   * that image (and its parents) are returned; if it is an image ID, similarly only that image (and
   * its parents) are returned and there would be no names referenced in the 'repositories' file for
   * this image ID. For details on the format, see the [export image endpoint](#operation/ImageGet).
   *
   * Expected answers: code 200 : File (no error) code 500 : ErrorResponse (server error)
   *
   * @param names
   *   Image names to filter by
   */
  def imageGetAll(names: Seq[String])
      : Request[Either[ResponseException[String, Exception], String]] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/images/get?names=${names}")
      .contentType("application/json")
      .response(asJson[String])

  /**
   * Return parent layers of an image.
   *
   * Expected answers: code 200 : Seq[HistoryResponseItem] (List of image layers) code 404 :
   * ErrorResponse (No such image) code 500 : ErrorResponse (Server error)
   *
   * @param name
   *   Image name or ID
   */
  def imageHistory(name: String)
      : Request[Either[ResponseException[String, Exception], Seq[HistoryResponseItem]]] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/images/${name}/history")
      .contentType("application/json")
      .response(asJson[Seq[HistoryResponseItem]])

  /**
   * Return low-level information about an image.
   *
   * Expected answers: code 200 : ImageInspect (No error) code 404 : ErrorResponse (No such image)
   * code 500 : ErrorResponse (Server error)
   *
   * @param name
   *   Image name or id
   */
  def imageInspect(name: String)
      : Request[Either[ResponseException[String, Exception], ImageInspect]] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/images/${name}/json")
      .contentType("application/json")
      .response(asJson[ImageInspect])

  /**
   * Returns a list of images on the server. Note that it uses a different, smaller representation
   * of an image than inspecting a single image.
   *
   * Expected answers: code 200 : Seq[ImageSummary] (Summary image data for the images matching the
   * query) code 500 : ErrorResponse (server error)
   *
   * @param all
   *   Show all images. Only images from a final layer (no children) are shown by default.
   * @param filters
   *   A JSON encoded value of the filters (a `map[string][]string`) to process on the images list.
   *   Available filters: - `before`=(`<image-name>[:<tag>]`, `<image id>` or `<image@digest>`) -
   *   `dangling=true` - `label=key` or `label=\"key=value\"` of an image label -
   *   `reference`=(`<image-name>[:<tag>]`) - `since`=(`<image-name>[:<tag>]`, `<image id>` or
   *   `<image@digest>`)
   * @param sharedSize
   *   Compute and show shared size as a `SharedSize` field on each image.
   * @param digests
   *   Show digest information as a `RepoDigests` field on each image.
   */
  def imageList(
      all: Option[Boolean] = None,
      filters: Option[String] = None,
      sharedSize: Option[Boolean] = None,
      digests: Option[Boolean] = None,
    ): Request[Either[ResponseException[String, Exception], Seq[ImageSummary]]] =
    basicRequest
      .method(
        Method.GET,
        uri"$baseUrl/images/json?all=${all}&filters=${filters}&shared-size=${sharedSize}&digests=${digests}",
      )
      .contentType("application/json")
      .response(asJson[Seq[ImageSummary]])

  /**
   * Load a set of images and tags into a repository. For details on the format, see the [export
   * image endpoint](#operation/ImageGet).
   *
   * Expected answers: code 200 : (no error) code 500 : ErrorResponse (server error)
   *
   * @param quiet
   *   Suppress progress details during load.
   * @param imagesTarball
   *   Tar archive containing images
   */
  def imageLoad(quiet: Option[Boolean] = None, imagesTarball: Option[String] = None)
      : Request[Either[ResponseException[String, Exception], Unit]] =
    basicRequest
      .method(Method.POST, uri"$baseUrl/images/load?quiet=${quiet}")
      .contentType("application/x-tar")
      .body(imagesTarball)
      .response(asString.mapWithMetadata(ResponseAs.deserializeRightWithError(_ => Right(()))))

  /**
   * Expected answers: code 200 : ImagePruneResponse (No error) code 500 : ErrorResponse (Server
   * error)
   *
   * @param filters
   *   Filters to process on the prune list, encoded as JSON (a `map[string][]string`). Available
   *   filters: - `dangling=<boolean>` When set to `true` (or `1`), prune only unused *and* untagged
   *   images. When set to `false` (or `0`), all unused images are pruned. - `until=<string>` Prune
   *   images created before this timestamp. The `<timestamp>` can be Unix timestamps, date
   *   formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the
   *   daemon machineâ€™s time. - `label` (`label=<key>`, `label=<key>=<value>`, `label!=<key>`, or
   *   `label!=<key>=<value>`) Prune images with (or without, in case `label!=...` is used) the
   *   specified labels.
   */
  def imagePrune(filters: Option[String] = None)
      : Request[Either[ResponseException[String, Exception], ImagePruneResponse]] =
    basicRequest
      .method(Method.POST, uri"$baseUrl/images/prune?filters=${filters}")
      .contentType("application/json")
      .response(asJson[ImagePruneResponse])

  /**
   * Push an image to a registry. If you wish to push an image on to a private registry, that image
   * must already have a tag which references the registry. For example,
   * `registry.example.com/myimage:latest`. The push is cancelled if the HTTP connection is closed.
   *
   * Expected answers: code 200 : (No error) code 404 : ErrorResponse (No such image) code 500 :
   * ErrorResponse (Server error)
   *
   * @param name
   *   Image name or ID.
   * @param xRegistryAuth
   *   A base64url-encoded auth configuration. Refer to the [authentication
   *   section](#section/Authentication) for details.
   * @param tag
   *   The tag to associate with the image on the registry.
   */
  def imagePush(
      name: String,
      xRegistryAuth: String,
      tag: Option[String] = None,
    ): Request[Either[ResponseException[String, Exception], Unit]] =
    basicRequest
      .method(Method.POST, uri"$baseUrl/images/${name}/push?tag=${tag}")
      .contentType("application/json")
      .header("X-Registry-Auth", xRegistryAuth.toString)
      .response(asString.mapWithMetadata(ResponseAs.deserializeRightWithError(_ => Right(()))))

  /**
   * Search for an image on Docker Hub.
   *
   * Expected answers: code 200 : Seq[ImageSearchResponseItem] (No error) code 500 : ErrorResponse
   * (Server error)
   *
   * @param term
   *   Term to search
   * @param limit
   *   Maximum number of results to return
   * @param filters
   *   A JSON encoded value of the filters (a `map[string][]string`) to process on the images list.
   *   Available filters: - `is-automated=(true|false)` - `is-official=(true|false)` -
   *   `stars=<number>` Matches images that has at least 'number' stars.
   */
  def imageSearch(
      term: String,
      limit: Option[Int] = None,
      filters: Option[String] = None,
    ): Request[Either[ResponseException[String, Exception], Seq[ImageSearchResponseItem]]] =
    basicRequest
      .method(
        Method.GET,
        uri"$baseUrl/images/search?term=${term}&limit=${limit}&filters=${filters}",
      )
      .contentType("application/json")
      .response(asJson[Seq[ImageSearchResponseItem]])

  /**
   * Tag an image so that it becomes part of a repository.
   *
   * Expected answers: code 201 : (No error) code 400 : ErrorResponse (Bad parameter) code 404 :
   * ErrorResponse (No such image) code 409 : ErrorResponse (Conflict) code 500 : ErrorResponse
   * (Server error)
   *
   * @param name
   *   Image name or ID to tag.
   * @param repo
   *   The repository to tag in. For example, `someuser/someimage`.
   * @param tag
   *   The name of the new tag.
   */
  def imageTag(
      name: String,
      repo: Option[String] = None,
      tag: Option[String] = None,
    ): Request[Either[ResponseException[String, Exception], Unit]] =
    basicRequest
      .method(Method.POST, uri"$baseUrl/images/${name}/tag?repo=${repo}&tag=${tag}")
      .contentType("application/json")
      .response(asString.mapWithMetadata(ResponseAs.deserializeRightWithError(_ => Right(()))))

end ImageApi
