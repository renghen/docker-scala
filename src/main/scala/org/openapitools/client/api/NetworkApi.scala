/**
 * Docker Engine API The Engine API is an HTTP API served by Docker Engine. It is the API the Docker
 * client uses to communicate with the Engine, so everything the Docker client can do can be done
 * with the API. Most of the client's commands map directly to API endpoints (e.g. `docker ps` is
 * `GET /containers/json`). The notable exception is running containers, which consists of several
 * API calls. # Errors The API uses standard HTTP status codes to indicate the success or failure of
 * the API call. The body of the response will be JSON in the following format: ``` { \"message\":
 * \"page not found\" } ``` # Versioning The API is usually changed in each release, so API calls
 * are versioned to ensure that clients don't break. To lock to a specific version of the API, you
 * prefix the URL with its version, for example, call `/v1.30/info` to use the v1.30 version of the
 * `/info` endpoint. If the API version specified in the URL is not supported by the daemon, a HTTP
 * `400 Bad Request` error message is returned. If you omit the version-prefix, the current version
 * of the API (v1.43) is used. For example, calling `/info` is the same as calling `/v1.43/info`.
 * Using the API without a version-prefix is deprecated and will be removed in a future release.
 * Engine releases in the near future should support this version of the API, so your client will
 * continue to work even if it is talking to a newer Engine. The API uses an open schema model,
 * which means server may add extra properties to responses. Likewise, the server will ignore any
 * extra query parameters and request body properties. When you write clients, you need to ignore
 * additional properties in responses to ensure they do not break when talking to newer daemons. #
 * Authentication Authentication for registries is handled client side. The client has to send
 * authentication details to various endpoints that need to communicate with registries, such as
 * `POST /images/(name)/push`. These are sent as `X-Registry-Auth` header as a [base64url
 * encoded](https://tools.ietf.org/html/rfc4648#section-5) (JSON) string with the following
 * structure: ``` { \"username\": \"string\", \"password\": \"string\", \"email\": \"string\",
 * \"serveraddress\": \"string\" } ``` The `serveraddress` is a domain/IP without a protocol.
 * Throughout this structure, double quotes are required. If you have already got an identity token
 * from the [`/auth` endpoint](#operation/SystemAuth), you can just pass this instead of
 * credentials: ``` { \"identitytoken\": \"9cbaf023786cd7...\" } ```
 *
 * The version of the OpenAPI document: 1.43
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech Do not edit the class manually.
 */
package org.openapitools.client.api

import org.openapitools.client.model.ErrorResponse
import org.openapitools.client.model.Network
import org.openapitools.client.model.NetworkConnectRequest
import org.openapitools.client.model.NetworkCreateRequest
import org.openapitools.client.model.NetworkCreateResponse
import org.openapitools.client.model.NetworkDisconnectRequest
import org.openapitools.client.model.NetworkPruneResponse
import org.openapitools.client.core.JsonSupport.{*, given}
import sttp.client4.*
import sttp.model.Method

object NetworkApi:
  def apply(baseUrl: String = "http://localhost/v1.43") = new NetworkApi(baseUrl)

end NetworkApi

class NetworkApi(baseUrl: String):

  /**
   * Expected answers: code 200 : (No error) code 403 : ErrorResponse (Operation not supported for
   * swarm scoped networks) code 404 : ErrorResponse (Network or container not found) code 500 :
   * ErrorResponse (Server error)
   *
   * @param id
   *   Network ID or name
   * @param container
   */
  def networkConnect(id: String, container: NetworkConnectRequest)
      : Request[Either[ResponseException[String, Exception], Unit]] =
    basicRequest
      .method(Method.POST, uri"$baseUrl/networks/${id}/connect")
      .contentType("application/json")
      .body(container)
      .response(asString.mapWithMetadata(ResponseAs.deserializeRightWithError(_ => Right(()))))

  /**
   * Expected answers: code 201 : NetworkCreateResponse (No error) code 400 : ErrorResponse (bad
   * parameter) code 403 : ErrorResponse (operation not supported for pre-defined networks) code 404
   * : ErrorResponse (plugin not found) code 500 : ErrorResponse (Server error)
   *
   * @param networkConfig
   *   Network configuration
   */
  def networkCreate(networkConfig: NetworkCreateRequest)
      : Request[Either[ResponseException[String, Exception], NetworkCreateResponse]] =
    basicRequest
      .method(Method.POST, uri"$baseUrl/networks/create")
      .contentType("application/json")
      .body(networkConfig)
      .response(asJson[NetworkCreateResponse])

  /**
   * Expected answers: code 204 : (No error) code 403 : ErrorResponse (operation not supported for
   * pre-defined networks) code 404 : ErrorResponse (no such network) code 500 : ErrorResponse
   * (Server error)
   *
   * @param id
   *   Network ID or name
   */
  def networkDelete(id: String): Request[Either[ResponseException[String, Exception], Unit]] =
    basicRequest
      .method(Method.DELETE, uri"$baseUrl/networks/${id}")
      .contentType("application/json")
      .response(asString.mapWithMetadata(ResponseAs.deserializeRightWithError(_ => Right(()))))

  /**
   * Expected answers: code 200 : (No error) code 403 : ErrorResponse (Operation not supported for
   * swarm scoped networks) code 404 : ErrorResponse (Network or container not found) code 500 :
   * ErrorResponse (Server error)
   *
   * @param id
   *   Network ID or name
   * @param container
   */
  def networkDisconnect(id: String, container: NetworkDisconnectRequest)
      : Request[Either[ResponseException[String, Exception], Unit]] =
    basicRequest
      .method(Method.POST, uri"$baseUrl/networks/${id}/disconnect")
      .contentType("application/json")
      .body(container)
      .response(asString.mapWithMetadata(ResponseAs.deserializeRightWithError(_ => Right(()))))

  /**
   * Expected answers: code 200 : Network (No error) code 404 : ErrorResponse (Network not found)
   * code 500 : ErrorResponse (Server error)
   *
   * @param id
   *   Network ID or name
   * @param verbose
   *   Detailed inspect output for troubleshooting
   * @param scope
   *   Filter the network by scope (swarm, global, or local)
   */
  def networkInspect(
      id: String,
      verbose: Option[Boolean] = None,
      scope: Option[String] = None,
    ): Request[Either[ResponseException[String, Exception], Network]] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/networks/${id}?verbose=${verbose}&scope=${scope}")
      .contentType("application/json")
      .response(asJson[Network])

  /**
   * Returns a list of networks. For details on the format, see the [network inspect
   * endpoint](#operation/NetworkInspect). Note that it uses a different, smaller representation of
   * a network than inspecting a single network. For example, the list of containers attached to the
   * network is not propagated in API versions 1.28 and up.
   *
   * Expected answers: code 200 : Seq[Network] (No error) code 500 : ErrorResponse (Server error)
   *
   * @param filters
   *   JSON encoded value of the filters (a `map[string][]string`) to process on the networks list.
   *   Available filters: - `dangling=<boolean>` When set to `true` (or `1`), returns all networks
   *   that are not in use by a container. When set to `false` (or `0`), only networks that are in
   *   use by one or more containers are returned. - `driver=<driver-name>` Matches a network's
   *   driver. - `id=<network-id>` Matches all or part of a network ID. - `label=<key>` or
   *   `label=<key>=<value>` of a network label. - `name=<network-name>` Matches all or part of a
   *   network name. - `scope=[\"swarm\"|\"global\"|\"local\"]` Filters networks by scope (`swarm`,
   *   `global`, or `local`). - `type=[\"custom\"|\"builtin\"]` Filters networks by type. The
   *   `custom` keyword returns all user-defined networks.
   */
  def networkList(filters: Option[String] = None)
      : Request[Either[ResponseException[String, Exception], Seq[Network]]] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/networks?filters=${filters}")
      .contentType("application/json")
      .response(asJson[Seq[Network]])

  /**
   * Expected answers: code 200 : NetworkPruneResponse (No error) code 500 : ErrorResponse (Server
   * error)
   *
   * @param filters
   *   Filters to process on the prune list, encoded as JSON (a `map[string][]string`). Available
   *   filters: - `until=<timestamp>` Prune networks created before this timestamp. The
   *   `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g.
   *   `10m`, `1h30m`) computed relative to the daemon machineâ€™s time. - `label` (`label=<key>`,
   *   `label=<key>=<value>`, `label!=<key>`, or `label!=<key>=<value>`) Prune networks with (or
   *   without, in case `label!=...` is used) the specified labels.
   */
  def networkPrune(filters: Option[String] = None)
      : Request[Either[ResponseException[String, Exception], NetworkPruneResponse]] =
    basicRequest
      .method(Method.POST, uri"$baseUrl/networks/prune?filters=${filters}")
      .contentType("application/json")
      .response(asJson[NetworkPruneResponse])

end NetworkApi
