/**
 * Docker Engine API The Engine API is an HTTP API served by Docker Engine. It is the API the Docker
 * client uses to communicate with the Engine, so everything the Docker client can do can be done
 * with the API. Most of the client's commands map directly to API endpoints (e.g. `docker ps` is
 * `GET /containers/json`). The notable exception is running containers, which consists of several
 * API calls. # Errors The API uses standard HTTP status codes to indicate the success or failure of
 * the API call. The body of the response will be JSON in the following format: ``` { \"message\":
 * \"page not found\" } ``` # Versioning The API is usually changed in each release, so API calls
 * are versioned to ensure that clients don't break. To lock to a specific version of the API, you
 * prefix the URL with its version, for example, call `/v1.30/info` to use the v1.30 version of the
 * `/info` endpoint. If the API version specified in the URL is not supported by the daemon, a HTTP
 * `400 Bad Request` error message is returned. If you omit the version-prefix, the current version
 * of the API (v1.43) is used. For example, calling `/info` is the same as calling `/v1.43/info`.
 * Using the API without a version-prefix is deprecated and will be removed in a future release.
 * Engine releases in the near future should support this version of the API, so your client will
 * continue to work even if it is talking to a newer Engine. The API uses an open schema model,
 * which means server may add extra properties to responses. Likewise, the server will ignore any
 * extra query parameters and request body properties. When you write clients, you need to ignore
 * additional properties in responses to ensure they do not break when talking to newer daemons. #
 * Authentication Authentication for registries is handled client side. The client has to send
 * authentication details to various endpoints that need to communicate with registries, such as
 * `POST /images/(name)/push`. These are sent as `X-Registry-Auth` header as a [base64url
 * encoded](https://tools.ietf.org/html/rfc4648#section-5) (JSON) string with the following
 * structure: ``` { \"username\": \"string\", \"password\": \"string\", \"email\": \"string\",
 * \"serveraddress\": \"string\" } ``` The `serveraddress` is a domain/IP without a protocol.
 * Throughout this structure, double quotes are required. If you have already got an identity token
 * from the [`/auth` endpoint](#operation/SystemAuth), you can just pass this instead of
 * credentials: ``` { \"identitytoken\": \"9cbaf023786cd7...\" } ```
 *
 * The version of the OpenAPI document: 1.43
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech Do not edit the class manually.
 */
package org.openapitools.client.api

import org.openapitools.client.model.AuthConfig
import org.openapitools.client.model.ErrorResponse
import org.openapitools.client.model.EventMessage
import org.openapitools.client.model.SystemAuthResponse
import org.openapitools.client.model.SystemDataUsageResponse
import org.openapitools.client.model.SystemInfo
import org.openapitools.client.model.SystemVersion
import org.openapitools.client.core.JsonSupport.{*, given}
import sttp.client4.*
import sttp.model.Method

object SystemApi:
  def apply(baseUrl: String = "http://localhost/v1.43") = new SystemApi(baseUrl)

end SystemApi

class SystemApi(baseUrl: String):

  /**
   * Validate credentials for a registry and, if available, get an identity token for accessing the
   * registry without password.
   *
   * Expected answers: code 200 : SystemAuthResponse (An identity token was generated successfully.)
   * code 204 : (No error) code 401 : ErrorResponse (Auth error) code 500 : ErrorResponse (Server
   * error)
   *
   * @param authConfig
   *   Authentication to check
   */
  def systemAuth(authConfig: Option[AuthConfig] = None)
      : Request[Either[ResponseException[String, Exception], SystemAuthResponse]] =
    basicRequest
      .method(Method.POST, uri"$baseUrl/auth")
      .contentType("application/json")
      .body(authConfig)
      .response(asJson[SystemAuthResponse])

  /**
   * Expected answers: code 200 : SystemDataUsageResponse (no error) code 500 : ErrorResponse
   * (server error)
   *
   * @param `type`
   *   Object types, for which to compute and return data.
   */
  def systemDataUsage(`type`: Seq[String])
      : Request[Either[ResponseException[String, Exception], SystemDataUsageResponse]] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/system/df?type=${`type`}")
      .contentType("application/json")
      .response(asJson[SystemDataUsageResponse])

  /**
   * Stream real-time events from the server. Various objects within Docker report events when
   * something happens to them. Containers report these events: `attach`, `commit`, `copy`,
   * `create`, `destroy`, `detach`, `die`, `exec_create`, `exec_detach`, `exec_start`, `exec_die`,
   * `export`, `health_status`, `kill`, `oom`, `pause`, `rename`, `resize`, `restart`, `start`,
   * `stop`, `top`, `unpause`, `update`, and `prune` Images report these events: `delete`, `import`,
   * `load`, `pull`, `push`, `save`, `tag`, `untag`, and `prune` Volumes report these events:
   * `create`, `mount`, `unmount`, `destroy`, and `prune` Networks report these events: `create`,
   * `connect`, `disconnect`, `destroy`, `update`, `remove`, and `prune` The Docker daemon reports
   * these events: `reload` Services report these events: `create`, `update`, and `remove` Nodes
   * report these events: `create`, `update`, and `remove` Secrets report these events: `create`,
   * `update`, and `remove` Configs report these events: `create`, `update`, and `remove` The
   * Builder reports `prune` events
   *
   * Expected answers: code 200 : EventMessage (no error) code 400 : ErrorResponse (bad parameter)
   * code 500 : ErrorResponse (server error)
   *
   * @param since
   *   Show events created since this timestamp then stream new events.
   * @param until
   *   Show events created until this timestamp then stop streaming.
   * @param filters
   *   A JSON encoded value of filters (a `map[string][]string`) to process on the event list.
   *   Available filters: - `config=<string>` config name or ID - `container=<string>` container
   *   name or ID - `daemon=<string>` daemon name or ID - `event=<string>` event type -
   *   `image=<string>` image name or ID - `label=<string>` image or container label -
   *   `network=<string>` network name or ID - `node=<string>` node ID - `plugin`=<string> plugin
   *   name or ID - `scope`=<string> local or swarm - `secret=<string>` secret name or ID -
   *   `service=<string>` service name or ID - `type=<string>` object to filter by, one of
   *   `container`, `image`, `volume`, `network`, `daemon`, `plugin`, `node`, `service`, `secret` or
   *   `config` - `volume=<string>` volume name
   */
  def systemEvents(
      since: Option[String] = None,
      until: Option[String] = None,
      filters: Option[String] = None,
    ): Request[Either[ResponseException[String, Exception], EventMessage]] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/events?since=${since}&until=${until}&filters=${filters}")
      .contentType("application/json")
      .response(asJson[EventMessage])

  /**
   * Expected answers: code 200 : SystemInfo (No error) code 500 : ErrorResponse (Server error)
   */
  def systemInfo(): Request[Either[ResponseException[String, Exception], SystemInfo]] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/info")
      .contentType("application/json")
      .response(asJson[SystemInfo])

  /**
   * This is a dummy endpoint you can use to test if the server is accessible.
   *
   * Expected answers: code 200 : String (no error) Headers : Swarm - Contains information about
   * Swarm status of the daemon, and if the daemon is acting as a manager or worker node.
   * Docker-Experimental - If the server is running with experimental mode enabled Cache-Control -
   * Pragma - API-Version - Max API Version the server supports Builder-Version - Default version of
   * docker image builder The default on Linux is version \"2\" (BuildKit), but the daemon can be
   * configured to recommend version \"1\" (classic Builder). Windows does not yet support BuildKit
   * for native Windows images, and uses \"1\" (classic builder) as a default. This value is a
   * recommendation as advertised by the daemon, and it is up to the client to choose which builder
   * to use. code 500 : ErrorResponse (server error) Headers : Cache-Control - Pragma -
   */
  def systemPing(): Request[Either[ResponseException[String, Exception], String]] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/_ping")
      .contentType("application/json")
      .response(asJson[String])

  /**
   * This is a dummy endpoint you can use to test if the server is accessible.
   *
   * Expected answers: code 200 : String (no error) Headers : Swarm - Contains information about
   * Swarm status of the daemon, and if the daemon is acting as a manager or worker node.
   * Docker-Experimental - If the server is running with experimental mode enabled Cache-Control -
   * Pragma - API-Version - Max API Version the server supports Builder-Version - Default version of
   * docker image builder code 500 : ErrorResponse (server error)
   */
  def systemPingHead(): Request[Either[ResponseException[String, Exception], String]] =
    basicRequest
      .method(Method.HEAD, uri"$baseUrl/_ping")
      .contentType("application/json")
      .response(asJson[String])

  /**
   * Returns the version of Docker that is running and various information about the system that
   * Docker is running on.
   *
   * Expected answers: code 200 : SystemVersion (no error) code 500 : ErrorResponse (server error)
   */
  def systemVersion(): Request[Either[ResponseException[String, Exception], SystemVersion]] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/version")
      .contentType("application/json")
      .response(asJson[SystemVersion])

end SystemApi
